Lesson 2

git init   from a new folder will create a new repository with that folder name.

mvalent2 reflections $ git init
Initialized empty Git repository in /Users/mvalent2/mgvlib.cablevision/Personal/Udacity/How to Use Git and GitHub/reflections/.git/


git status    will now show us the status of that repository

mvalent2 (master #) reflections $ git status
On branch master

Initial commit

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	lesson_1_reflections.txt

nothing added to commit but untracked files present (use "git add" to track)



Note, git init   does NOT create an initial commit.  We need to do that ourselves.
Thus the git status shows us an initial commit as blank  and untracked files


What happens when you initialize a repository? Why do you need to do it?

git will create a new repository with the folder name and create a hidden  .git   folder that contains the meta data for the repository
This is needed for tracking your code changes under this new repository


to add files to the new git repository, the need to be included via   git add  command
then when we use   git commit   they'll be added from the "staging" area to the repository

git add <filename1>
git add <filename2>
or
git add *     to add all files


How is the staging area different from the working directory and the repository? What value do you think it offers?
the staging area shows items that have been added to tracking that can then be committed to the respository. Working directory can have files that aren't necessarily going to be tracked.
It allows for separate experimentation without having to muddy the repository.


git commit opens the editor for a commit
add your commit message to the top of the file so that this information can appear in the git log output

(hint: ensure that the editor is configured properly)
git config --global core.editor "/Applications/Sublime\ Text\ 2.app/Contents/SharedSupport/bin/subl -n -w"

or use
git commit -m "somemessage"
and the editor isn't required

git diff   with not arguments will show the differences between files in the working directory and the files in the staging area
if you add the file to the staging area and run  git diff  again, then the files that are added will not show in the diff as they are now the same

to see the difference between the staging area and the committed files, then use
git diff --staged

git diff commitX commitY  shows differences between two commits.  learned in lesson 1









